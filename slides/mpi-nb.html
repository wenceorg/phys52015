<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>MPI: more point to point</title>
    <link rel="shortcut icon" href="/phys52015/favicon.svg" />
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/reset.min.css"
          integrity="sha512-Mjxkx+r7O/OLQeKeIBCQ2yspG1P5muhAtv/J+p2/aPnSenciZWm5Wlnt+NOUNA4SHbnBIE/R2ic0ZBiCXdQNUg=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/reveal.min.css"
          integrity="sha512-WFGU7IgfYR0dq5aORzbD+NApAXdExNZFb7LaoO8olYImBW/iZxAwjKEuT+oYcFR6gOd+DAFssq/icMn8YVbQxQ=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/theme/solarized.min.css"
          integrity="sha512-sUF1FAUpi9yPXCDOPsRwzh71zrCVkcT4SfwxBlQeHwMbH1aTGcSdI00GRLaH6iXRSBTazGH/u6sGQTc1tGqofg=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/plugin/highlight/zenburn.min.css"
          integrity="sha512-JPxjD2t82edI35nXydY/erE9jVPpqxEJ++6nYEoZEpX2TRsmp2FpZuQqZa+wBCen5U16QZOkMadGXHCfp+tUdg=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/reveal.min.js"
            integrity="sha512-K7P1+dtPriNNHlE4aJr+JKx1X6R0wvy24QBqL2CxaHc4XdkQjrH2t2FCrgoxZGMh6s1TgigNLEdrWa6NJra6Zg=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/plugin/markdown/markdown.min.js"
            integrity="sha512-VMIcHSU7cVYRxUYr9l/t/iRO98QUfuTw8inT0mFklWb6HhKwLkjA0F24O42RL39RKGenNEK/TlEWB2NEy8w4Ng=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/plugin/highlight/highlight.min.js"
            integrity="sha512-NVdqCvsrfhXUYzGTEGGBFf5jxheVVcglfdvO8r+WdG0BKMrRYvaiCGIC0S+wf4hkE3Xq43gTd1k3Mwl/UNgdvw=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.1.2/plugin/math/math.min.js"
            integrity="sha512-3HmB6PODGpVVNHOzPd/iva9nhAtO8o5lNh8ukjgcswV+iQTRZFqdMWJW25dvcSploiX4I4M6uuUKIV9BaogQhw=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style type="text/css">
  .container {
      display: flex;
  }
  .col {
      flex: 1;
  }
  .reveal p {
      text-align: left;
  }
  .reveal .center {
      margin-left: auto;
      margin-right: auto;
      display: inline-block;
  }
  .reveal ul {
      display: block;
  }
  .reveal ol {
      display: block;
  }
  .reveal img {
      margin-left: auto;
      margin-right: auto;
      display: block;
  }
</style>
</head>
<body>
<div class="reveal">
<div class="slides">
<section>
<section data-markdown><textarea data-template>

# MPI: more point to point

<div class="center">

[Notes](/phys52015/notes/mpi/point-to-point/) and
[more](/phys52015/notes/mpi/point-to-point-nb/)

</div>

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Reminder

- Two-sided communication (sender and receiver)
- Processes identified by `(communicator, rank)` pair
- Data passed as void pointer
- Data described by `count` and `MPI_Datatype`.
```c
int *data = malloc(...);
/* Send the first ten integers in data to rank 4 in COMM_WORLD */
MPI_Send(data, 10, MPI_INT, 4, 0, MPI_COMM_WORLD);
```

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Deadlocks

- `MPI_Send` is _blocking_
  - That means it waits until the buffer you pass in is safe to reuse

![Sketch of `MPI_Send`](/phys52015/images/manual/mpi-ssend-cartoon.svg)

</textarea></section>
<section data-markdown><textarea data-template>

### What happens if the receive never arrives?

- Sender waits _forever_.

![MJ](https://i.kym-cdn.com/photos/images/original/001/762/214/ff4.jpg)

</textarea></section>
<section data-markdown><textarea data-template>

### Why didn't that happen with my code?

- MPI has three blocking sends 
  1. `MPI_Send`
  2. `MPI_Ssend` (synchronous send)
  3. `MPI_Bsend` (buffered send)

- `MPI_Ssend` _always_ waits 
- `MPI_Bsend` we provide a buffer for MPI to copy into

</textarea></section>
<section data-markdown><textarea data-template>

### `MPI_Bsend`

![Sketch of `MPI_Bsend`](/phys52015/images/manual/mpi-bsend-cartoon.svg)

</textarea></section>
<section data-markdown><textarea data-template>

### `MPI_Send`

- MPI manages buffer
  - Behaves like `MPI_Bsend` if message is small enough 
  - Switches to `MPI_Ssend` if not 
- **No minimum buffer size is guaranteed**

[Example: ptp deadlock](/phys52015/notes/mpi/point-to-point/#deadlock-exercise)

</textarea></section>
<section data-markdown><textarea data-template>

### Avoiding deadlocks

1. I just have pairwise exchanges

    - Can use `MPI_Sendrecv`, which merges a send and receive (the
    source and destinations don't have to match).
     

2. My communication pattern is more complicated

    - [Non-blocking messages](/phys52015/notes/mpi/point-to-point-nb/)

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Non-blocking messages

- Idea: separate _sending_ (receiving) message from waiting on completion
  
```c [4,8]
int MPI_Isend(const void *buffer, 
              int count, MPI_Datatype dtype, 
              int dest, int tag, MPI_Comm comm,
              MPI_Request *request);
int MPI_Irecv(void *buffer, 
              int count, MPI_Datatype dtype,
              int source, int tag, MPI_Comm comm,
              MPI_Request *request);
```

</textarea></section>
<section data-markdown><textarea data-template>

### Checking for completion

- With a `request` object in hand, can either 
  1. _test_ if a message is completed (`MPI_Test`)
  2. _wait_ for a message to complete (`MPI_Wait`)
  
```c
int *data = ...;
int flag = 0;
MPI_Request req;
MPI_Isend(data, ..., &req);
...;
MPI_Test(req, &flag, MPI_STATUS_IGNORE);
if (flag) {
   /* Message has been sent */
} else {
   /* Message not yet sent */
}
```

</textarea></section>
<section data-markdown><textarea data-template>

### Picture

![Sketch of `MPI_Isend`](/phys52015/images/manual/mpi-issend-cartoon.svg)

</textarea></section>
<section data-markdown><textarea data-template>

### Advantages of this approach

- Can "post" sends (receives) for many messages at once
  - MPI library can "complete" them as the matching pair arrives
- This can lead to less waiting in messages

</textarea></section>
<section data-markdown><textarea data-template>

### Example: blocking receives

- Only one receive ready at any one time.

```c

if (rank == 0) {
  for (int i = 1; i < size; i++) {
    MPI_Recv(..., i /* source */, ...);
  }
} else {
  MPI_Ssend(..., 0 /* dest */, ...);
}
```

</textarea></section>
<section data-markdown><textarea data-template>

### Example: nonblocking receives

- All receives ready at once

```c
if (rank == 0) {
  MPI_Request *reqs = malloc(...);
  for (int i = 1; i < size; i++) {
    MPI_Irecv(..., i, ..., &reqs[i-1]);
  }
  /* Wait for completion of all receives */
  MPI_Waitall(reqs, size-1, MPI_STATUSES_IGNORE);
} else {
  MPI_Ssend(..., 0, ...);
}
```

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Communication performance, network latency

- In the [ping-pong exercise](/phys52015/exercises/mpi-ping-pong/)
  build a simple model for message time
  
$$
T(b) = \alpha + \beta b
$$

- Time to send a message depends on the latency $\alpha$ and the
  inverse bandwidth $\beta$.

</textarea></section>
<section data-markdown><textarea data-template>

### Last year's results

![Ping pong timing](/phys52015/images/auto/ping-pong-timing-lots.svg)

</textarea></section>
<section data-markdown><textarea data-template>

### Reducing message time

- With blocking messages, minimum simulation time is

  $$T_\text{blocking} = T_\text{compute} + T_\text{message}$$
  
- Non-blocking messages, minimum time is

  $$T_\text{non-block} = \min(T_\text{compute}, T_\text{message})$$

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Waiting for ~Godot~ many messages

- Need one request object per non-blocking message
- Three options
  1. Wait for all requests `MPI_Waitall`
  2. Wait for one request `MPI_Waitany`
  3. Wait for at least one request `MPI_Waitsome`

</textarea></section>
<section data-markdown><textarea data-template>

### Typical pattern
```c
MPI_Request *requests;

nsend = ...;
nrecv = ...;

requests = malloc((nsend+nrecv)*sizeof(*requests));

for (int i = 0; i < nrecv; i++) {
  MPI_Irecv(..., &requests[i]);
}

for (int i = 0; i < nsend; i++) {
  MPI_Isend(..., &requests[i + nrecv]);
}

/* Some work that doesn't depend on the messages */
```

</textarea></section>
<section data-markdown><textarea data-template>

### Waiting options

- Everything
```c
MPI_Waitall(nsend+nrecv, requests, MPI_STATUSES_IGNORE);
```
- A message
```c
int which;
MPI_Waitany(nsend+nrecv, requests, &which, MPI_STATUSES_IGNORE);
```
- Some messages
```c
int *indices = malloc((nsend+nrecv)*sizeof(*indices));
int nfinished;
MPI_Waitsome(nsend+nrecv, requests, &nfinished, indices,
             MPI_STATUSES_IGNORE);
```

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Major point

- Message is not complete until succesfully waited on or tested
- **Not allowed** to look at receive buffer (or modify send buffer)
  until the request has completed
  
```c
MPI_Request *requests;
nsend = ...;
nrecv = ...;
requests = malloc((nsend+nrecv)*sizeof(*requests));
for (int i = 0; i < nrecv; i++) {
  MPI_Irecv(data, ..., &requests[i]);
}
/* Not allowed */
if (data[0]) {
  ...;
}
MPI_Waitall(..., requests);
```

</textarea></section>
</section>
<section>
<section data-markdown><textarea data-template>

## Exercises

- [MPI ping pong](/phys52015/exercises/mpi-ping-pong/)
- [Gather to zero](/phys52015/notes/mpi/point-to-point-nb/)
- [Halo exchanges](/phys52015/exercises/mpi-stencil/) This one is harder

</textarea></section>
</section>
</div>
</div>
<script>
  function extend() {
    var target = {};
    for (var i = 0; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }

  // default options to init reveal.js
  var defaultOptions = {
    controls: true,
    progress: true,
    history: true,
    slideNumber: true,
    center: true,
    transition: 'none', // none/fade/slide/convex/concave/zoom
    plugins: [
      RevealMarkdown,
      RevealHighlight,
      RevealMath,
    ],
    markdown: {smartypants: true}
  };

  // options from URL query string
  var queryOptions = Reveal().getQueryHash() || {};

  var options = extend(defaultOptions, {}, queryOptions);
</script>


<script>
  Reveal.initialize(options);
</script>
</body>
</html>